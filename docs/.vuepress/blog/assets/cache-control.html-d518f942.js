import{_ as a}from"./framework-c27b6911.js";import{r as l,o as e,c as o,d as s,e as p,a as r,b as c}from"./app-ec006255.js";const t="/assets/cache-control-max-age-40eac862.png",i={},F=c(`<h1 id="缓存" tabindex="-1"><a class="header-anchor" href="#缓存" aria-hidden="true">#</a> 缓存</h1><p>HTTP缓存会存储与请求关联的响应, 并将存储的响应复用于后续请求。</p><h2 id="基于age的缓存策略" tabindex="-1"><a class="header-anchor" href="#基于age的缓存策略" aria-hidden="true">#</a> 基于age的缓存策略</h2><p>存储的HTTP响应有两种状态: <strong>fresh</strong> 和 <strong>state</strong>。<em>fresh</em> 表示响应仍然有效, 可以重复使用, 而 <em>state</em> 状态表示缓存的响应已经过期。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="shiki monokai" style="background-color:#272822;" tabindex="0"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">const</span><span style="color:#F8F8F2;"> http </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">require</span><span style="color:#F8F8F2;">(</span><span style="color:#E6DB74;">&#39;http&#39;</span><span style="color:#F8F8F2;">)</span></span>
<span class="line"><span style="color:#F8F8F2;">http.</span><span style="color:#A6E22E;">createServer</span><span style="color:#F8F8F2;">(</span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">req</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">res</span><span style="color:#F8F8F2;">) {</span></span>
<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#F92672;">if</span><span style="color:#F8F8F2;"> (req.url </span><span style="color:#F92672;">===</span><span style="color:#F8F8F2;"> </span><span style="color:#E6DB74;">&#39;/main.js&#39;</span><span style="color:#F8F8F2;">) {</span></span>
<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#66D9EF;font-style:italic;">const</span><span style="color:#F8F8F2;"> js </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> fs.</span><span style="color:#A6E22E;">readFileSync</span><span style="color:#F8F8F2;">(</span><span style="color:#E6DB74;">&#39;./main.js&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&#39;utf-8&#39;</span><span style="color:#F8F8F2;">)</span></span>
<span class="line"><span style="color:#F8F8F2;">    res.</span><span style="color:#A6E22E;">writeHead</span><span style="color:#F8F8F2;">(</span><span style="color:#AE81FF;">200</span><span style="color:#F8F8F2;">, {</span></span>
<span class="line"><span style="color:#F8F8F2;">      </span><span style="color:#E6DB74;">&#39;Content-Type&#39;</span><span style="color:#F8F8F2;">: </span><span style="color:#E6DB74;">&#39;text/javascript&#39;</span><span style="color:#F8F8F2;">,</span></span>
<span class="line"><span style="color:#F8F8F2;">      </span><span style="color:#E6DB74;">&#39;Cache-Control&#39;</span><span style="color:#F8F8F2;">: </span><span style="color:#E6DB74;">&#39;max-age=10&#39;</span></span>
<span class="line"><span style="color:#F8F8F2;">    })</span></span>
<span class="line"><span style="color:#F8F8F2;">    res.</span><span style="color:#A6E22E;">end</span><span style="color:#F8F8F2;">(js)</span></span>
<span class="line"><span style="color:#F8F8F2;">  }</span></span>
<span class="line"><span style="color:#F8F8F2;">})</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上实例, <strong>max-age=10</strong> 表示 如果在请求了资源后的 10s 内再次发起请求 则使用缓存。超过10s 则重新请求新的资源内容!</p><p><img src="`+t+`" alt="Cache-Control/max-age"></p><h2 id="验证响应" tabindex="-1"><a class="header-anchor" href="#验证响应" aria-hidden="true">#</a> 验证响应</h2><p>过时的响应不会被立即丢弃。HTTP有一种机制, 可以通过询问源服务器将陈旧的响应转换为新的响应。这称为验证。验证是通过使用包含 <strong>If-Modified-Since</strong> 或 <strong>If-None-Match</strong> 请求标头的条件请求完成的。</p><p><strong>Last-Modified/If-Modified-Since</strong></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="shiki monokai" style="background-color:#272822;" tabindex="0"><code><span class="line"><span style="color:#88846F;">// 响应头</span></span>
<span class="line"><span style="color:#F8F8F2;">{</span></span>
<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#E6DB74;">&#39;Connection&#39;</span><span style="color:#F8F8F2;">: </span><span style="color:#E6DB74;">&#39;keep-alive&#39;</span></span>
<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#E6DB74;">&#39;Content-Type&#39;</span><span style="color:#F8F8F2;">: </span><span style="color:#E6DB74;">&#39;text/javascript&#39;</span></span>
<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#E6DB74;">&#39;Date&#39;</span><span style="color:#F8F8F2;">: </span><span style="color:#E6DB74;">&#39;Mon, 15 May 2023 06:38:29 GMT&#39;</span></span>
<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#E6DB74;">&#39;Keep-Alive&#39;</span><span style="color:#F8F8F2;">: </span><span style="color:#E6DB74;">&#39;timeout=5&#39;</span></span>
<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#E6DB74;">&#39;Last-Modified&#39;</span><span style="color:#F8F8F2;">: </span><span style="color:#E6DB74;">&#39;Mon May 15 2023 14:34:02 GMT&#39;</span></span>
<span class="line"><span style="color:#F8F8F2;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">// 再次请求时</span></span>
<span class="line"><span style="color:#F8F8F2;">{</span></span>
<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#E6DB74;">&#39;Host&#39;</span><span style="color:#F8F8F2;">: </span><span style="color:#E6DB74;">&#39;192.168.0.141:3000&#39;</span></span>
<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#E6DB74;">&#39;If-Modified-Since&#39;</span><span style="color:#F8F8F2;">: </span><span style="color:#E6DB74;">&#39;Mon May 15 2023 14:34:02 GMT&#39;</span></span>
<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#E6DB74;">&#39;Referer&#39;</span><span style="color:#F8F8F2;">: </span><span style="color:#E6DB74;">&#39;http://192.168.0.141:3000/&#39;</span></span>
<span class="line"><span style="color:#F8F8F2;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Etag/If-None-Match</strong></p><p><strong>Etag</strong> 响应标头的值是服务器生成的任意值。如果 <strong>Etag</strong> 标头的值与请求头中的 <strong>If-None-Match</strong>值相同, 则服务器将返回 <strong>304 Not Modified</strong>。 但是，如果服务器确定请求的资源现在应该具有不同的 ETag 值，则服务器将其改为 200 OK 和资源的最新版本进行响应</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="shiki monokai" style="background-color:#272822;" tabindex="0"><code><span class="line"><span style="color:#88846F;">// 响应头</span></span>
<span class="line"><span style="color:#F8F8F2;">{</span></span>
<span class="line"><span style="color:#F8F8F2;">  Date: </span><span style="color:#E6DB74;">&#39;Mon, 15 May 2023 07:36:38 GMT&#39;</span></span>
<span class="line"><span style="color:#F8F8F2;">  Etag: </span><span style="color:#AE81FF;">1234</span></span>
<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#E6DB74;">&#39;Keep-Alive&#39;</span><span style="color:#F8F8F2;">: </span><span style="color:#E6DB74;">&#39;timeout=5&#39;</span></span>
<span class="line"><span style="color:#F8F8F2;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">// 请求头</span></span>
<span class="line"><span style="color:#F8F8F2;">{</span></span>
<span class="line"><span style="color:#F8F8F2;">  Host: </span><span style="color:#E6DB74;">&#39;192.168.0.141:3000&#39;</span></span>
<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#E6DB74;">&#39;If-None-Match&#39;</span><span style="color:#F8F8F2;">: </span><span style="color:#AE81FF;">1234</span></span>
<span class="line"><span style="color:#F8F8F2;">  Referer: </span><span style="color:#E6DB74;">&#39;http://192.168.0.141:3000/&#39;</span></span>
<span class="line"><span style="color:#F8F8F2;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果不希望重复使用响应, 而是始终希望从服务器获取最新内容, 可以使用 <strong>no-cache</strong> 指令强制验证。<strong>no-cache</strong> 指令不会阻止响应的存储, 而是 阻止在没有重新验证的情况下重用响应。</p><p>如果不希望将响应存储在任何缓存中, 使用 <strong>no-store</strong>。</p><h2 id="vary" tabindex="-1"><a class="header-anchor" href="#vary" aria-hidden="true">#</a> Vary</h2><p>区分响应的本质是URL, 首部字段 <strong>Vary</strong> 可对缓存进行控制。</p>`,18),d={href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching#vary_%E5%93%8D%E5%BA%94",target:"_blank",rel:"noopener noreferrer"};function y(v,m){const n=l("ExternalLinkIcon");return e(),o("div",null,[F,s("p",null,[s("a",d,[p("Cache-Control/Vary"),r(n)])])])}const h=a(i,[["render",y],["__file","cache-control.html.vue"]]);export{h as default};
