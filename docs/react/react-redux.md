# React Redux

  React Redux is the official Redux UI binding library for React. If you are using Redux and React togther,
  you should also use React Redux to bind these two libraries.

:::tip
You can ensure that each connected component only extracts the specific pieces of data from the store state that 
are needed by that component. This means that you own component will need to re-render less ofen.
:::

## Provider

  Once the store is created, we can make is available to our React components by putting a React Redux Provider
  around out application.
```jsx
// usage
import { Provider } from 'react-redux'
import { createRoot } from 'react-dom/client'
const root = createRoot(document.getElementById('root'))
root.render(
  <Provider>
    <App store={store}/>
  </Provider>
)
```
## connect

  React Redux provides a connect function for you to react values from the Redux store(and re-read the values when the store updates)
  
  Arguments:
1. mapStateToProps  called every time the store state chagnes. It receives the entire store state, and should return an object
of data this component needs

2. mapDispatchToProps : (functions / object)
  参数可以是对象 或者 函数, 一般来说是一个函数 包含当前组件需要的 actionCreator。

```jsx
// 将上面的计数器 使用useSelector 和 useDispatch 通过connect 方法实现
// store.js
const increment = () => ({
  type: INCREMENT
})
const decrement = () => ({
  type: DECREMENT
})

// App.jsx
import { decrement, increment } from './store'

const mapStateToProps = state => ({count: state})
const mapDispatchToProps = {
  decrement,
  increment
}

const Counter = connect(mapStateToProps, mapDispatchToProps)((props) => {
  return (
    <div>
      <button className='primary-button' onClick={props.increment}>Increment</button>
      <span>{props.count}</span>
      <button className='primary-button' onClick={props.decrement}>Decrement</button>
    </div>
  )
})
```
<div class="_redux_connect_counter"></div>
<ClientOnly>
  <ReduxConnectCounter/>
</ClientOnly>

  这是一个通过connect方法实现的counter计数器, 效果和使用useSelector/useDispatch 相同。

**Common ways of calling connect**

1. 如果connect函数两个参数都没有传递, 那么组件将不会更新(当store的数据更新时)。 组件会接受props.dispatch

2. 如果只传递了mapStatetoProps,但是没有传递mapDispatchToProps, 组件会在store数据更新时更新, 并接受props.dispatch。

3. 如果只传递了mapDispatchToProps,但是没有传递mapStateToProps, 组件在store数据更新时不会更新, 并接受action生成器(传递给mapDispatchToProps里的函数)

4. 两个参数mapDispatchToProps 和 mapStateToProps都传递了,那么组件会正常更新并且接受action生成器。

| | Do Not Subscribe to the Store | Subscribe to the Store |
|  ------------- |:-------------: |:-------------:|
| Do Not Inject Action Creators | connect()(Component) | connect(mapStateToProps)(Component) | 
| Inject Action Creators | connect(null, mapDispatchToProps)(Component) | connect(mapStateToProps, mapDispatchToProps)(Component) |

:::tip
只要第一个参数mapStateToProps没有传递, 那么当store中的数据更新时,当前组件不会触发重新渲染。
:::

## mapStateToProps

  mapStateToProps Functions Should Be Pure and Synchronous

```js
function mapStateToProps(state, ownProps?) {
  return {
    // ...
  }
}
```
  mapStateToProps 作为第一个参数传递给connect函数, 如果store的数据更新了, 那么mapStateToProps函数便会执行。
  如果不想订阅store的数据更新, 可以显式地给connect传递 null 或者 undefined.

1. Arguments

  mapStateToProps的第一个参数 是完整的 Redux store state(值和 store.getState()返回的一样。)
```js
function mapStateToProps(state) {
  return { todoList: todos.todos }
}
export default connect(mapStateToProps)(TodoList)
```

  也可以给mapStateToProps 传递第二个可选的参数ownProps。当前组件接受的props. (This argument will contain all of the props given
  to the wrapper component that was generated by connect)

2. Return

  mapStateToProps的返回值 应该是一个纯对象里面包含当前组件需要的数据, 该对象的每个字段将最作为props传递到当前组件 。
  如果返回的对象 任何一个字段的值修改了, 组件将会重新渲染。

| | state => stateProps | (state,ownProps) => stateProps |
|  ------------- |:-------------: |:-------------:|
| mapStateToProps runs when | store state changes | store state changes or any field of ownProps is different | 
| component re-renders when | any field of stateProps is different | any field of stateProps is different or any field of ownProps is different |

  因为mapStateToProps 可以接受两个参数, 所以传递的参数个数 也会有不同的行为。
```js
// mapStateToProps will not receive ownProps
function mapStateToProps(state) {
  console.log(state) // state
  console.log(arguments[1]) // undefined
}
const mapStateToProps = (state, ownProps = {}) => {
  console.log(state) // state
  console.log(ownProps) // {}
}


// it will receive ownProps
function mapStateToProps(state, ownProps) {
  console.log(state) // state
  console.log(ownProps) // ownProps
}

function mapStateToProps() {
  console.log(arguments[0]) // state
  console.log(arguments[1]) // ownProps
}

function mapStateToProps(...args) {
  console.log(args[0]) // state
  console.log(args[1]) // ownProps
}
```

## mapDispatchToProps

  mapDispatchToProps 是 connect函数的第二个参数。
1. By default, a connected component receives props.dispatch and can dispatch actions itself.

2. connect can accept an argument called mapDispatchToProps, which lets you create functions that dispatch when called, and pass those functions as props to your component.

  mapDispatchToProps 有两种形式。
1. 第一种是 一个函数, 可以接受dispatch 和一个可选的 ownProps
2. 第二种方式时一个对象。使用对象的形式更容易使用
:::tip
We recommend always using the “object shorthand” form of mapDispatchToProps, unless you have a specific reason to customize the dispatching behavior.
:::

### Function

  下面是一个案例, 两个按钮, 分别接受不同的multiple 作为props, 并把mapDispatchToProps 作为函数使用, 此时传递第二个参数 ownProps,
  并把组件接受的props 作为payload 传递到 reducer.
```js
// store.js
function double_reducer(state = 1, action) {
  const { type, payload } = action
  switch(type) {
    case DOUBLE_INCREMENT:
      return state * payload
    case DOUBLE_DECREMENT:
      return state / payload;
    default:
      return state
  }
}

function triple_reducer(state = 1, action) {
  const { type, payload } = action
  switch(type) {
    case TRIPLE_INCREMENT:
      return state * payload
    case TRIPLE_DECREMENT:
      return state / payload
    default:
      return state
  }
}

export default createStore(combineReducers({
  double: double_reducer,
  triple: triple_reducer
}))


// App.jsx
function App() {
  return (
    <React.Fragment>
      <DoubleCounter multiple={2}/>
      <TripleCounter multiple={3}/>
    </React.Fragment>
  )
}

// Counter的 mapDispatchToProps
const mapDoubleDispatch = function(dispatch, ownProps) {
  // ownProps 接受的是 multiple, 此时作为 payload传递个 reducer.
  return {
    increment: () => dispatch({type: DOUBLE_INCREMENT, payload: ownProps.multiple}),
    decrement: () => dispatch({type: DOUBLE_DECREMENT, payload: ownProps.multiple})
  }
}
const mapTripleDispatch = function(dispatch, ownProps) {
  return {
    increment: () => dispatch({type: TRIPLE_INCREMENT, payload: ownProps.multiple}),
    decrement: () => dispatch({type: TRIPLE_DECREMENT, payload: ownProps.multiple})
  }
}
```

<div class="_react_map_dispatch"></div>
<ClientOnly>
  <ReactDispatch/>
</ClientOnly>

  如果mapDispatchToProps是一个函数, 该函数需返回一个对象, 对象的每个字段是 一个函数(action creator)用来更新store的状态。
  这个对象将会和组件的props合并, 所以可以直接通过组件的 props[actionCreator] 方式调用。

  如果mapDispatchToProps 这个参数传递给了connect, 那么组件将不会再接受默认的dispatch.

### Object

```js
const mapDispatchToProps = {
  increment,
  decrement,
  reset,
}
```

1. Each field of the mapDispatchToProps object is assumed to be an action creator
2. Your component will no longer receive dispatch as a prop.

  如果传递了mapDispatchToProps 但是还想在组件使用dispatch, 可以使用返回函数的方式, 显式地在返回的对象里 添加dispatch.
```js
const mapDispatchToProps = (dispatch) => {
  return {
    increment: () => dispatch(increment()),
    decrement: () => dispatch(decrement()),
    dispatch
  }
}
```

## Hooks

  React Redux Hooks 允许组件去订阅store的数据更新和派发 actions。

### useSelector

  The useSelector hooks lets our component extract whatever pieces of data it needs from the Redux store state.
1. useSelector 可以返回任意类型的值,不仅仅是一个对象。返回值可以直接在组件中使用。
2. useSelector 不会接受ownProps 作为第二个参数, 但是可以通过函数闭包 读取组件的 props

```js
function Counter() {
  const count = useSelector(state => state)
  return (
    <div>{count}</div>
  )
}


const TodoListItem = (props) => {
  const todo = useSelector((state) => state.todos[props.id])
  return <div>{todo.text}</div>
}
```
## useDispatch


  The useDispatch hook can give us the actual dispatch method from the Redux store,so we can dispatch actions when the user does
  something like clicking on a button.

  Now we can use the React Redux hooks to let React components interact with the Redux store.
```js
const dispatch = useDispatch()
const todos = useSelector(state => state.todos)
```
```js
// store.js
const INCREMENT = 'counter/increment'
const DECREMENT = 'counter/decrement'
function reducer(state = 0, action) {
  const { type } = action
  switch(type) {
    case INCREMENT:
      return state + 1
    case DECREMENT:
      return state - 1
    default: 
      return state
  }
}
const store = createStore(reducer, 0)

// App.jsx
import { useSelector, useDispatch, Provider } from 'react-redux'
import { createRoot } from 'react-dom/client'
function Counter() {
  const count = useSelector(state => state)
  const dispatch = useDispatch()
  const handleIncrement = () => {
    dispatch({
      type: INCREMENT
    })
  }
  const handleDecrement = () => {
    dispatch({
      type: DECREMENT
    })
  }
  return (
    <div>
      <button className='primary-button' onClick={handleIncrement}>Increment</button>
      <span>{count}</span>
      <button className='primary-button' onClick={handleDecrement}>Decrement</button>
    </div>
  )
}
const root = createRoot(document.getElementById('root'))
root.render(
  <Provider store={store}>
    <Counter/>
  </Provider>
)
```
  Any time an action has been dispatched and the Redux store has been updated, useSelector will re-run our selector function.

<div class="_react_redux_counter"></div>
<ClientOnly>
  <ReduxCounter/>
</ClientOnly>
  
  这个是上面代码的展示效果