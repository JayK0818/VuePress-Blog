# React Redux

  React Redux is the official Redux UI binding library for React. If you are using Redux and React together,
  you should also use React Redux to bind these two libraries.

:::tip
You can ensure that each connected component only extracts the specific pieces of data from the store state that 
are needed by that component. This means that you own component will need to re-render less often.
:::

## Provider

  Once the store is created, we can make is available to our React components by putting a React Redux Provider
  around out application.
```jsx
// usage
import { Provider } from 'react-redux'
import { createRoot } from 'react-dom/client'
const root = createRoot(document.getElementById('root'))
root.render(
  <Provider>
    <App store={store}/>
  </Provider>
)
```

  Provider 组件也剋提供一个可选的 context 参数。
```jsx
const ThemeContext = React.createContext('dark')
function MyProvider() {
  return (
    <Provider context={ThemeContext} store={store}>{props.children}</Provider>
  )
}
```

## connect

  The connect() function connects a React component to a Redux store. It does not modify the component class passed
  to it. instead, it returns a new, connected component class that wrap the component you passed in.
  
  Arguments:
1. mapStateToProps  called every time the store state changes. It receives the entire store state, and should return an object
of data this component needs

2. mapDispatchToProps : (functions / object)
  参数可以是对象 或者 函数, 一般来说是一个函数 包含当前组件需要的 actionCreator。

3. mergeProps: (stateProps, dispatchProps, ownProps) => Object
  是一个可选参数, 它决定最终你的组件会接受到怎样的props参数,如果没有提供的话, 组件将接受 {...ownProps, ...stateProps, ...dispatchProps}。

4. options:
  这也是一个可选参数, React-Redux v6允许传递一个自定义的context, 需要在Provider 和 当前组件传递 context。
```js
const MyContext = React.createContext();
connect(mapStateToProps, mapDispatchToProps, null, { context: MyContext })(
  MyComponent
)
```

```jsx
// 将上面的计数器 使用useSelector 和 useDispatch 通过connect 方法实现
// store.js
const increment = () => ({
  type: INCREMENT
})
const decrement = () => ({
  type: DECREMENT
})

// App.jsx
import { decrement, increment } from './store'

const mapStateToProps = state => ({count: state})
const mapDispatchToProps = {
  decrement,
  increment
}

const Counter = connect(mapStateToProps, mapDispatchToProps)((props) => {
  return (
    <div>
      <button className='primary-button' onClick={props.increment}>Increment</button>
      <span>{props.count}</span>
      <button className='primary-button' onClick={props.decrement}>Decrement</button>
    </div>
  )
})
```

**Common ways of calling connect**

1. 如果connect函数两个参数都没有传递, 那么组件将不会更新(当store的数据更新时)。 组件会接受props.dispatch

2. 如果只传递了mapStateToProps,但是没有传递mapDispatchToProps, 组件会在store数据更新时更新, 并接受props.dispatch。

3. 如果只传递了mapDispatchToProps,但是没有传递mapStateToProps, 组件在store数据更新时不会更新, 并接受action生成器(传递给mapDispatchToProps里的函数)

4. 两个参数mapDispatchToProps 和 mapStateToProps都传递了,那么组件会正常更新并且接受action生成器。

| | Do Not Subscribe to the Store | Subscribe to the Store |
|  ------------- |:-------------: |:-------------:|
| Do Not Inject Action Creators | connect()(Component) | connect(mapStateToProps)(Component) | 
| Inject Action Creators | connect(null, mapDispatchToProps)(Component) | connect(mapStateToProps, mapDispatchToProps)(Component) |

:::tip
只要第一个参数mapStateToProps没有传递, 那么当store中的数据更新时,当前组件不会触发重新渲染。
:::

## mapStateToProps

  mapStateToProps Functions Should Be Pure and Synchronous

```js
function mapStateToProps(state, ownProps?) {
  return {
    // ...
  }
}
```
  mapStateToProps 作为第一个参数传递给connect函数, 如果store的数据更新了, 那么mapStateToProps函数便会执行。
  如果不想订阅store的数据更新, 可以显式地给connect传递 null 或者 undefined.

1. Arguments

  mapStateToProps的第一个参数 是完整的 Redux store state(值和 store.getState()返回的一样。)
```js
function mapStateToProps(state) {
  return { todoList: todos.todos }
}
export default connect(mapStateToProps)(TodoList)
```

  也可以给mapStateToProps 传递第二个可选的参数ownProps。当前组件接受的props. (This argument will contain all of the props given
  to the wrapper component that was generated by connect)

2. Return

  mapStateToProps的返回值 应该是一个纯对象里面包含当前组件需要的数据, 该对象的每个字段将最作为props传递到当前组件 。
  如果返回的对象 任何一个字段的值修改了, 组件将会重新渲染。

| | state => stateProps | (state,ownProps) => stateProps |
|  ------------- |:-------------: |:-------------:|
| mapStateToProps runs when | store state changes | store state changes or any field of ownProps is different | 
| component re-renders when | any field of stateProps is different | any field of stateProps is different or any field of ownProps is different |

  因为mapStateToProps 可以接受两个参数, 所以传递的参数个数 也会有不同的行为。
```js
// mapStateToProps will not receive ownProps
function mapStateToProps(state) {
  console.log(state) // state
  console.log(arguments[1]) // undefined
}
const mapStateToProps = (state, ownProps = {}) => {
  console.log(state) // state
  console.log(ownProps) // {}
}


// it will receive ownProps
function mapStateToProps(state, ownProps) {
  console.log(state) // state
  console.log(ownProps) // ownProps
}

function mapStateToProps() {
  console.log(arguments[0]) // state
  console.log(arguments[1]) // ownProps
}

function mapStateToProps(...args) {
  console.log(args[0]) // state
  console.log(args[1]) // ownProps
}
```

## mapDispatchToProps

  mapDispatchToProps 是 connect函数的第二个参数。
1. By default, a connected component receives props.dispatch and can dispatch actions itself.

2. connect can accept an argument called mapDispatchToProps, which lets you create functions that dispatch when called, and pass those functions as props to your component.

  mapDispatchToProps 有两种形式。
1. 第一种是 一个函数, 可以接受dispatch 和一个可选的 ownProps
2. 第二种方式时一个对象。使用对象的形式更容易使用
:::tip
We recommend always using the “object shorthand” form of mapDispatchToProps, unless you have a specific reason to customize the dispatching behavior.
:::

### Function

  下面是一个案例, 两个按钮, 分别接受不同的multiple 作为props, 并把mapDispatchToProps 作为函数使用, 此时传递第二个参数 ownProps,
  并把组件接受的props 作为payload 传递到 reducer.
```js
// store.js
function double_reducer(state = 1, action) {
  const { type, payload } = action
  switch(type) {
    case DOUBLE_INCREMENT:
      return state * payload
    case DOUBLE_DECREMENT:
      return state / payload;
    default:
      return state
  }
}

function triple_reducer(state = 1, action) {
  const { type, payload } = action
  switch(type) {
    case TRIPLE_INCREMENT:
      return state * payload
    case TRIPLE_DECREMENT:
      return state / payload
    default:
      return state
  }
}

export default createStore(combineReducers({
  double: double_reducer,
  triple: triple_reducer
}))


// App.jsx
function App() {
  return (
    <React.Fragment>
      <DoubleCounter multiple={2}/>
      <TripleCounter multiple={3}/>
    </React.Fragment>
  )
}

// Counter的 mapDispatchToProps
const mapDoubleDispatch = function(dispatch, ownProps) {
  // ownProps 接受的是 multiple, 此时作为 payload传递个 reducer.
  return {
    increment: () => dispatch({type: DOUBLE_INCREMENT, payload: ownProps.multiple}),
    decrement: () => dispatch({type: DOUBLE_DECREMENT, payload: ownProps.multiple})
  }
}
const mapTripleDispatch = function(dispatch, ownProps) {
  return {
    increment: () => dispatch({type: TRIPLE_INCREMENT, payload: ownProps.multiple}),
    decrement: () => dispatch({type: TRIPLE_DECREMENT, payload: ownProps.multiple})
  }
}
```

  如果mapDispatchToProps是一个函数, 该函数需返回一个对象, 对象的每个字段是 一个函数(action creator)用来更新store的状态。
  这个对象将会和组件的props合并, 所以可以直接通过组件的 props[actionCreator] 方式调用。

  如果mapDispatchToProps 这个参数传递给了connect, 那么组件将不会再接受默认的dispatch.

### Object

```js
const mapDispatchToProps = {
  increment,
  decrement,
  reset,
}
```

1. Each field of the mapDispatchToProps object is assumed to be an action creator
2. Your component will no longer receive dispatch as a prop.

  如果传递了mapDispatchToProps 但是还想在组件使用dispatch, 可以使用返回函数的方式, 显式地在返回的对象里 添加dispatch.
```js
const mapDispatchToProps = (dispatch) => {
  return {
    increment: () => dispatch(increment()),
    decrement: () => dispatch(decrement()),
    dispatch
  }
}
```

## Hooks

  React Redux Hooks 允许组件去订阅store的数据更新和派发 actions。

### useSelector

  The useSelector hooks lets our component extract whatever pieces of data it needs from the Redux store state.
1. useSelector 可以返回任意类型的值,不仅仅是一个对象。返回值可以直接在组件中使用。
2. useSelector 不会接受ownProps 作为第二个参数, 但是可以通过函数闭包 读取组件的 props.
3. 和connect()函数的第一个参数mapStateToProps不同,useSelector()返回一个对象的话每次都是返回一个新的对象,会触发组件重新渲染。

3.1 多次调用useSelector(),每次分别返回一个单独的键值

3.2 使用类似reselect 第三方库, 只有返回对象的键值修改了才返回一个新的对象触发组件渲染。

3.3 给useSelector传递第二个参数 shallowEqual. (from React-Redux)

```js
import { shallowEqual, useSelector } from 'react-redux'
// later
const selectedData = useSelector((state) => ({value: state.count}), shallowEqual)
```

```js
// 简单用法
function Counter() {
  const count = useSelector(state => state)
  return (
    <div>{count}</div>
  )
}
// 依赖组件的props
const TodoListItem = (props) => {
  const todo = useSelector((state) => state.todos[props.id])
  return <div>{todo.text}</div>
}

// 使用reselect
const selectCompletedTodos = createSelector(
  state => state.todos,
  todos => todos.filter(todo => todo.completed).length
)
function App() {
  const length = useSelector(selectCompletedTodos)
  return (
    <div>{length}</div>
  )
}
```
  和connect() 不一样的是, useSelector() 在父组件重新渲染的时候不会阻止子组件重新渲染, 即使子组件的props没有改变。此时可以考虑
  使用React.memo()包裹组件.

```jsx
const Counter = React.memo(function() {
  const counter = useSelector((state) => state.counter)
  return (
    <div>{name}: {counter}</div>
  )
})
```
### useDispatch

  This hook returns a reference to the dispatch function from the Redux store. You may use it to dispatch actions as needed

  Now we can use the React Redux hooks to let React components interact with the Redux store.
```js
const dispatch = useDispatch()
```
:::tip
The dispatch function reference will be stable as long as the same store instance is being passed to the Provider.
Normally, that store instance never changes in an application.
```js
const Todos = () => {
  const dispatch = useDispatch()
  useEffect(() => {
    dispatch(fetchTodos())
    // Safe to add dispatch to the dependencies array
  }, [dispatch])
}
```
:::
```js
// store.js
const INCREMENT = 'counter/increment'
const DECREMENT = 'counter/decrement'
function reducer(state = 0, action) {
  const { type } = action
  switch(type) {
    case INCREMENT:
      return state + 1
    case DECREMENT:
      return state - 1
    default: 
      return state
  }
}
const store = createStore(reducer, 0)

// App.jsx
import { useSelector, useDispatch, Provider } from 'react-redux'
import { createRoot } from 'react-dom/client'
function Counter() {
  const count = useSelector(state => state)
  const dispatch = useDispatch()
  const handleIncrement = () => {
    dispatch({
      type: INCREMENT
    })
  }
  const handleDecrement = () => {
    dispatch({
      type: DECREMENT
    })
  }
  return (
    <div>
      <button className='primary-button' onClick={handleIncrement}>Increment</button>
      <span>{count}</span>
      <button className='primary-button' onClick={handleDecrement}>Decrement</button>
    </div>
  )
}
const root = createRoot(document.getElementById('root'))
root.render(
  <Provider store={store}>
    <Counter/>
  </Provider>
)
```

```jsx
const Button = memo((props) => {
  console.log('render')
  return (
    <button onClick={props.increment}>increment</button>
  )
})

function App() {
  const dispatch = useDispatch()
  const increment = useCallback(() => {
    dispatch({type: 'increment'})
  }, [dispatch])
  return (
    <Button increment={increment}/>
  )
}
// 上述demo 在父组件更新的时候 不会触发子组件的更新。
```

### useStore

  This Hook returns a reference to the same Redux store that was passed in to the Provider component.

```js
import { useStore } from 'react-redux'

export const CounterComponent = ({ value }) => {
  const store = useStore()

  // EXAMPLE ONLY! Do not do this in a real app.
  // The component will not automatically update if the store state changes
  return <div>{store.getState()}</div>
}
```

